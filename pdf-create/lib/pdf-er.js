
module.exports = {
	getURLAsPDF,
	renderPageAsPDF
};





// Third-party packages
const puppeteer = require( "puppeteer" );

// Constant declarations
let pathToBrowser = "/usr/bin/google-chrome-stable";
if ( process.env.NODE_ENV != "production" ) {
	pathToBrowser = "/Applications/Google Chrome.app/Contents/MacOS/Google Chrome";
}






// Define the header and footer
let styles = `
	<style>
		.edge {
			margin: 0 auto;
			display: flex;
			width: 91%;
			justify-content: space-between;
			background-color: yellow;
			font-family: Helvetica, sans-serif;
			font-size: 6px;
		}
		.edge.top {
			padding: 0 0 5px;
			border-bottom: 1px solid rgba( 0, 0, 0, 0.19 );
		}
		.edge.bottom {
			padding: 5px 0 0;
			border-top: 1px dashed rgba( 0, 0, 0, 0.19 );
		}
	</style>
`;
let headerTemplate = `
	<div class="edge top">
		<div class="title">Quote for #A105</div>
		<div class="date"></div>
	</div>
`;
let footerTemplate = `
	<div class="edge bottom">
		<div>Generated by someone</div>
		<div>
			<span class="pageNumber"></span>
			/
			<span class="totalPages"></span>
		</div>
	</div>
`;


async function getBrowser ( executablePath ) {

	let options = {
		headless: true
	}
	// For Ubuntu
	if ( process.env.NODE_ENV == "production" )
		options.args = [ "--no-sandbox" ]

	if ( executablePath )
		options.executablePath = executablePath

	const browser = await puppeteer.launch( options );
	// const incognitoContext = browser.createIncognitoBrowserContext();

	return browser;

}

async function getURLAsPDF ( url, fileName, options ) {

	options = options || { };

		// Get the browser
	const browser = await getBrowser( pathToBrowser );
		// Open a new page (tab)
	const page = await browser.newPage();
		// Set a cookie ( if provided )
	if ( options.cookie )
		await page.setCookie( cookie );
		// Go to the URL and wait until network is idle
	await page.goto( url, { waitUntil: "networkidle2" } );

		// Build the markup within the page ( if data is provided )
	if ( options.data ) {
		await page.evaluate( function ( data ) {

			var unitDetailsMarkup = __UI.templates.unitDetails( {
				points: data.points
			} );
			$( ".js_section_unit_details_and_mods" ).html( unitDetailsMarkup );

			return new Promise( ( res, rej ) => {
				setTimeout( function () {
					res( true );
				}, 1000 );
			} );

		}, options.data );
	}

		// Print the page as a PDF
	// await page.emulateMedia( "screen" );
	await page.pdf( {
		path: fileName,
		format: options.format || "A4",
		margin: {
			top: "50px",
			bottom: "50px",
			left: "0",
			right: "0",
		},
		// printBackground: true,
		displayHeaderFooter: true,
		headerTemplate: styles + headerTemplate,
		footerTemplate: footerTemplate
	} );
		// Close the page (tab)
	await page.close();
		// Close the browser
	await browser.close();

}

async function renderPageAsPDF ( pageContent, fileName, options ) {

	options = options || { };

		// Get the browser
	const browser = await getBrowser( pathToBrowser );
		// Open a new page (tab)
	const page = await browser.newPage();

		// Set the content of the page
	await page.setContent( pageContent );

	// await page.emulateMedia( "screen" );
		// Print the page as a PDF
	await page.pdf( {
		path: fileName,
		format: options.format || "A4",
		margin: {
			top: "50px",
			bottom: "50px",
			left: "0",
			right: "0",
		},
		// printBackground: true,
		displayHeaderFooter: true,
		headerTemplate: styles + headerTemplate,
		footerTemplate: footerTemplate
	} );
		// Close the page (tab)
	await page.close();
		// Close the browser
	await browser.close();

}
